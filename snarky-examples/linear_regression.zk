let input_precision = 32i;
let inner_precision = 40i; // Needs to be large enough to hold all the sums
let decimal_point = 16i;
let number_of_points = 2i;


let sum = fun( l : list(field)) : field => {
	List.fold_left(Field.(+))(0)(l);
	// potential overflow check for large lists
};

let two_to_the : int -> field = fun (n) => {
  Big_int.shift_left_big_int(Big_int.unit_big_int, n)
  |> Big_int.string_of_big_int
  |> Field.of_string;
};

let to_bits_signed = fun(length: int, x: field) => {
  let y = Field.( + )(x, two_to_the(length - 1i));
  let bits = Field.to_bits(~length=length, x);
  bits;
};


let take = fun (n, xs) => {
  loop(
    fun (self, (n, xs)) => {
    if (n = 0i) {
      [] ;
    } else {
      switch(xs) {
        | [] => []
        | x :: xstail => x :: self((n - 1i, xstail))
      };
    };
  }, (n, xs));
};

let reduce = fun(length_before: int, length_after: int, x: field) => {
  let bits = List.rev(take(length_after, List.rev(to_bits_signed(length_before, x))));
  Field.of_bits(bits);
};

let division = fun(a : field, b : field) => {
	let (x, r) = Prover {
      let a = Big_int.mult_big_int (Big_int.big_int_of_string(Field.to_string(a)), Big_int.power_int_positive_int(2i, decimal_point));
      let b = Big_int.big_int_of_string(Field.to_string(b));
      let (x, r) = Big_int.quomod_big_int(a, b);
      (Field.of_string(Big_int.string_of_big_int(x)), Field.of_string(Big_int.string_of_big_int(r)));
    };
    
    let bits = to_bits_signed(inner_precision, x);
    Field.Assert.lte(~bit_length=inner_precision, r, b);
    assert_r1(b, x, Field.( - )(Field.( * )(a, two_to_the(decimal_point)), r));

    let result = reduce(inner_precision + decimal_point, inner_precision, x);
    (result);
};

let mean = fun( l : list(field)) : field => {
	division(sum(l), Field.of_int(List.length(l)));
};

let main = fun(x1 : field, x2 : field, y1 : field, y2 : field, ()) => {
  let x : list#2(field) = [x1, x2];
  let y : list#2(field) = [y1, y2];

  // Compute means
  let x_cap = mean(x); 
  let y_cap = mean(y);
  let jfd = Prover {
    print_string("Mean of x values: ");
    print_endline(Field.to_string(x_cap));

    print_string("Mean of y values: ");
    print_endline(Field.to_string(y_cap));
  };
  let x_m: list#2(field) = List.map(fun (xi) => { Field.( - )(xi, x_cap); }, x);
  let y_m: list#2(field) = List.map(fun (yi) => { Field.( - )(yi, y_cap); }, y);

  //List.iter(fun(xi: field) => { Prover {
  //  print_string("x_m numerator: ");
  //  print_endline(Field.to_string(xi));
  //}; }, x);

  let numerator_prered = sum(List.map2(fun (x_1, x_2) => { Field.( * )(x_1, x_2); }, x_m, y_m));
  let numerator = reduce(inner_precision + decimal_point, inner_precision, numerator_prered);

  let denominator_prered = sum(List.map2(fun (x_1, x_2) => { Field.( * )(x_1, x_2); }, x_m, x_m));
  let denominator = reduce(inner_precision + decimal_point, inner_precision, denominator_prered);

  let jskfdanfd = Prover {
    print_string("m numerator: ");
    print_endline(Field.to_string(numerator));

    print_string("m denominator: ");
    print_endline(Field.to_string(denominator));
  };


  let m = division(numerator, denominator);
  let b = Field.( - )(y_cap, Field.( * ) (m, x_cap));
  let gigs = Prover {
    print_endline("y = m * x + b");
    print_string("m = ");
    print_endline(Field.to_string(m));

    print_string("b = ");
    print_endline(Field.to_string(b));
  };

  ();
};
