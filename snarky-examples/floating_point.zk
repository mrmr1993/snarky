// This is an incomplete example of floating point arithmetic. If you want to
// know more about it, ask Mathijs.

module Float = {
  let base_precision = 16i; // or 8...
  let div_precision = 16i;

  // x / 2^k, x < 2^m, k <= m
  type t =
    { k : int
    , m : int
    , x : field
    };

  type division =
    { q : field
    , r : field
    };

  let take = 
    fun (n, xs) => {
      loop(fun (take, (n, xs)) => {
        if (n = 0i) {
          [] ;
        } else {
          switch(xs) {
            | [] => []
            | x :: xs' => x :: self((n - 1i, xs'))
          };
        };
      }, (n, xs));
    };

  let low_bits = fun (t) => {
    let bits = List.rev(take(base_precision, List.rev(Field.to_bits(~length=t.m, t.x))));
    Field.of_bits(bits);
  };

  let ( * ) = fun (t1, t2) => {
    if (t1.m + t2.m < Field.size_in_bits) {
      { k: t1.k + t2.k
      , m: t1.m + t2.m
      , x: Field.( * )( t1.x , t2.x ) };
    } else {
      /* We could reduce just one but for ease of implementation we
         just reduce both. */
      let x1_trunc = low_bits(t1);
      let x2_trunc = low_bits(t2);
      { x = Field.( * )(x1_trunc, x2_trunc)
      , m = base_precision + base_precision
      , k = t1.k + t2.k + t1.m + t2.m - 2 * base_precision
      }
    };
  };

  let two_to_the : int -> field = fun (n) => {
    Big_int.shift_left_big_int(Big_int.unit_big_int, n)
    |> Big_int.string_of_big_int
    |> Field.of_string;
  };

  let low_bits_n = fun (t, n) => {
    let bits = List.rev(take(n, List.rev(Field.to_bits(~length=t.m, t.x))));
    Field.of_bits(bits);
  };

  let low_bits_n = fun (t, n) => {
    let bits = List.rev(List.take(n, List.rev(Field.to_bits(~length=t.m, t.x))));
    Field.of_bits(bits);
  };

  let ( + ) = fun (t1, t2) => {
    if (t1.k >= t2.k) {
      if t1.m + 1 < Field.size_in_bits) {
        let x2_shift = t1.k - t2.k;
        if (x2_shift < t2.m) {
          let x2_trunc = low_bits_n(t2, t2.m - k);
        } else {
          let x2_trunc = Field(0);
        }
        { k: t1.k,
          , m: t1.m + 1,
          , x: Field.( + )( t1.x , x2_trunc ) };
      } else {
        // TODO!
      }
    } else {
      if t1.m + 1 < Field.size_in_bits) {
        let x1_shift = t2.k - t1.k;
        if (x1_shift < t1.m) {
          let x1_trunc = low_bits_n(t1, t1.m - k);
        } else {
          let x1_trunc = Field(0);
        }
        { k: t2.k,
          , m: t2.m + 1,
          , x: Field.( + )( t2.x , x1_trunc ) };
      } else {
        // TODO!
      }
    }
  };


  /*
  * Verify division: a / b  = c 
  * assert on; b * x + r = a * 2^div_precision, where:
  * a = t1.x
  * b = t2.x
  * x = result
  * r = remainder
  * c = a * 2^div_precision */

  let ( / ) = fun (t1, t2, x: field, r: field) => {

    assert.r1(t2.x, Field.( + )(x, r), Field.( * )(t1.x, 2^div_precision);

    { k : t1.k - t2.k
    , m : t1.m + 1
    , x : x * 2^(t1.k - t2.k)
    }
  };
};


/*
* Note 1: The bigint lib uses the Zarith lib to compute euclidean division using ediv 
* and erem respectively returning the first and second element of ediv_rem. Point being: 
* there exist cleaner, more efficient, ways to do this.
* https://github.com/janestreet/bignum/blob/master/bigint/src/bigint.ml
* https://dsheets.github.io/codoc/zarith.1.3/z/index.html#/val:ediv_rem
*/