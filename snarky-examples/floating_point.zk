// This is an incomplete example of floating point arithmetic. If you want to
// know more about it, ask Mathijs.

module Float = {
  let base_precision = 16i; // or 8...
  let div_precision = 16i;

  // x / 2^k, x < 2^m, k <= m
  type t =
    { k : int
    , m : int
    , x : field
    };

  type division =
    { q : field
    , r : field
    };

  let take = fun (n, xs) => {
      loop(
        fun (self, (n, xs)) => {
        if (n = 0i) {
          [] ;
        } else {
          switch(xs) {
            | [] => []
            | x :: xstail => x :: self((n - 1i, xstail))
          };
        };
      }, (n, xs));
    };

  let low_bits = fun (t) => {
    let bits = List.rev(take(base_precision, List.rev(Field.to_bits(~length=t.m, t.x))));
    Field.of_bits(bits);
  };

  let ( * ) = fun (t1, t2) => {
    if (t1.m + t2.m < Field.size_in_bits) {
      { k: t1.k + t2.k
      , m: t1.m + t2.m
      , x: Field.( * )( t1.x , t2.x ) };
    } else {
      /* We could reduce just one but for ease of implementation we
         just reduce both. */
      let x1_trunc = low_bits(t1);
      let x2_trunc = low_bits(t2);
      { k: t1.k + t2.k + t1.m + t2.m - 2i * base_precision
      , m: base_precision + base_precision
      , x: Field.( * )(x1_trunc, x2_trunc)
      };
    };
  };

  let two_to_the : int -> field = fun (n) => {
    Big_int.shift_left_big_int(Big_int.unit_big_int, n)
    |> Big_int.string_of_big_int
    |> Field.of_string;
  };

  let low_bits_n = fun (t, n) => {
    let bits = List.rev(take(n, List.rev(Field.to_bits(~length=t.m, t.x))));
    Field.of_bits(bits);
  };

  let ( + ) = fun (t1, t2) => {
    if (t1.k >= t2.k) {
      if (t1.m + 1i < Field.size_in_bits) {
        let x2_shift = t1.k - t2.k;

        let x2_trunc = if (x2_shift < t2.m ) { low_bits_n(t2, t2.m - t2.k); } else { 0; };

        { k: t1.k
        , m: t1.m + 1i
        , x: Field.( + )( t1.x , x2_trunc ) };
      } else {
        // TODO!
        { k: t1.k
          , m: t1.m + 1i
          , x: Field.( + )( t1.x , t2.x ) };
        };
    } else {
      if (t1.m + 1i < Field.size_in_bits) {
        let x1_shift = t2.k - t1.k;
        let x1_trunc = if (x1_shift < t1.m) { low_bits_n(t1, t1.m - t1.k); } else { 0; };

        { k: t2.k
          , m: t2.m + 1i
          , x: Field.( + )( t2.x , x1_trunc ) };
      } else {
        // TODO!
        { k: t1.k
          , m: t1.m + 1i
          , x: Field.( + )( t1.x , t2.x ) };
      };
    };
  };


  /*
  * Verify division: a / b  = c 
  * assert on; b * x + r = a * 2^div_precision, or:
  * rank1; b * x = a * 2^div_precision - r, where:
  * a = t1.x
  * b = t2.x
  * x = result
  * r = remainder
  * c = a * 2^div_precision 
  */

  let ( / ) = fun ({ k:k1, m:m1, x:x1 } : t, { k:k2, m:m2, x:x2 }: t) => {
    let (x, r) = Prover {
      let a = Big_int.big_int_of_string(Field.to_string(x1));
      let b = Big_int.big_int_of_string(Field.to_string(x2));
      let (x, r) = Big_int.quomod_big_int(a, b);
      (Field.of_string(Big_int.string_of_big_int(x)), Field.of_string(Big_int.string_of_big_int(x)));
    };

    assert_r1(x2, x, Field.( - )(Field.( * )(x1, two_to_the(div_precision)), r));

    // TODO assert on negative r
    { k : Stdlib.{k1 - k2;}
    , m : Stdlib.{m1 + div_precision;}        //requires another thought
    , x : Field.(*)(x, two_to_the(Stdlib.{k1 - k2;}))
    };
  };
};


/*
* Note 1: The bigint lib uses the Zarith lib to compute euclidean division using ediv 
* and erem respectively returning the first and second element of ediv_rem. Point being: 
* there exist cleaner, more efficient, ways to do this.
* https://github.com/janestreet/bignum/blob/master/bigint/src/bigint.ml
* https://dsheets.github.io/codoc/zarith.1.3/z/index.html#/val:ediv_rem
*/